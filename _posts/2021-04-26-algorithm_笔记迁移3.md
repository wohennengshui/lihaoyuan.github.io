---
layout: post
title: "algorithm_笔记迁移3"
date: 2021-04-26
categories: algorithm
---
####  笔记 leetcode过往笔记迁移 序号为题号 代码目前截图方式 待整理

#### 1.两数之和，暴力的方法自然是两次for循环，并且判定是不是两个相等的，因为题里说了不允许一样，但是特别耗时 两次for 就是n的二次方的，于是优化，用哈希的方法，用C++的函数库 unordered_map <int ,int> hash ;定义个无序的容器，然后两种方法 分别是两次和一次 没差太多 1，先把所有数都放进去容器 构造哈希表 然后再用find 或者count （find表示搜索到这个数，如果！=nums.end()则说明找到结果了 否则表示到最后一个数了还没有 ，而count是表示找没找到 分别返回0，1那种）然后加上个限定条件 i,j不想等即可。又发现 人家给定的模版都是面向对象 也太复杂了在playground里面看到的 所以，用C++式C语言 超级简化 主要是掌握好unordered_map<int ,int>hash 够早的哈希表 和vector的方法 来当作哈希
![1]({{ site.url }}/assets/postImage/leetcode1.png)
#### 7.整数反转 题倒是挺简单的 就是有一些细节要把握好 先说大体内容 每一次把数取10 取余拿到最后一位然后把这个数加到反转的数里 然后把这个数除10  相当于减少掉最后一位 另外循环还要把这个数加到反转过的里面 最后要注意判断这个数是不是大于题意32为有符号整数 用了pow(2,31)，要注意是31次幂 另外还可以用INT_MAX /INT_MIN来表示
![7]({{ site.url }}/assets/postImage/leetcode7.png)
#### 13.罗马数字转整数  细节细节细节题吧 首先建立个无序的hash表 还是用unordered_map<char,int>hash；然后把每个罗马数字的字符都加入哈希表中 然后在判断的时候比较考验细节吧 首先在写for循环的时候就要考虑 因为每次都是判断当前和下一个的大小 那如果到了最后一个就无法判断了 因此 I<s.size()-1  剩下就是 定义加和减最后汇总一下 不过其实我只用一个result 也可以。 我觉得这个题有更好的思路 为什么我耗时这么慢呢 现在是O(n)吧 哈哈哈发现了 别人的用了switch比hashmap 快了好多，玄学。
![13]({{ site.url }}/assets/postImage/leetcode13.png)

















